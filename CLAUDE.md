# CLAUDE.md

> Rimworld MOD 汉化助手项目开发规范和最佳实践

---

## 项目概述

**Rimworld MOD 汉化助手** - 自动提取 Rimworld MOD 中可汉化的内容,辅助用户进行汉化工作,并保存汉化结果(不覆盖原文件)

### 核心技术栈
- **开发语言**: Python 3.9+
- **应用类型**: 混合应用 (CLI + GUI)
- **数据存储**: SQLite, 文件存储 (JSON/XML)
- **代码风格**: snake_case 命名规范

### 项目架构
```
CLI/GUI 层 → Service 层 → Logic 层 → Data 层 → Storage 层
                                              ├─ SQLite (翻译记录)
                                              └─ File Storage (MOD 文件, 配置)
```

**关键模块**:
- **提取模块**: `src/extractors/` - 从 MOD 文件中提取可汉化内容
- **汉化模块**: `src/translators/` - 管理汉化工作流程
- **存储模块**: `src/storage/` - 数据持久化和文件管理
- **界面模块**: `src/ui/` - CLI 和 GUI 界面

---

## 测试规范
- 测试覆盖率 > 80%
- 使用 Mock 模拟外部依赖
- Mock 数据存放在 `tests/data/` 目录
- 测试文件存放在 `tests/` 目录
- 使用 pytest 作为测试框架

---

## 架构规则(强制)

### 层职责定义
- **CLI/GUI 层**: ✅ 用户交互, 输入验证, 命令解析 / ❌ 业务逻辑, 数据处理
- **Service 层**: ✅ 协调各模块, 流程控制 / ❌ 直接数据库操作, 文件 I/O
- **Logic 层**: ✅ 业务逻辑, 数据转换, 规则处理 / ❌ 用户交互, 持久化操作
- **Data 层**: ✅ 数据访问, CRUD 操作 / ❌ 业务规则, 用户交互
- **Storage 层**: ✅ 文件读写, 数据库操作 / ❌ 业务逻辑判断

### 开发规则
1. **命名规范** - 统一使用 snake_case (函数、变量、文件名)
2. **依赖管理** - 使用 poetry 或 pip + requirements.txt 管理依赖
3. **错误处理** - 统一使用自定义异常类, 在 Service 层捕获并处理
4. **版本控制** - Git 提交必须使用 AskUserQuestion 工具询问用户同意
5. **禁止行为** - 禁止跨层调用, 禁止在 Logic 层直接操作数据库

### Claude Code 工具使用规范

**AI 必须使用的工具**:
- **AskUserQuestion**: 数据不足或需要决策时,必须主动询问用户
- **TodoWrite**: 跟踪多步骤任务的进度,及时更新任务状态
- **Read/Grep/Glob**: 修改前必须先分析现有代码,避免重复定义

---

## 核心开发实践(强制)

### 1. 代码修改前的分析(强制)

**所有代码修改前,必须先完成深度分析,理解项目架构后再设计方案。**

#### 调用链路分析要点
```
用户输入 → CLI/GUI → Service → Logic → Data → Storage
```

必须分析:
- **入口点**: 用户从哪个界面或命令进入
- **数据流转**: MOD 文件 → 提取 → 汉化 → 保存的完整流程
- **依赖关系**: 各模块之间的依赖
- **错误传播**: 文件读取失败、格式错误等异常的处理
- **缓存策略**: 是否需要缓存提取结果
- **文件安全**: 确保不覆盖原始 MOD 文件

#### 方案设计原则: KISS

设计前必须回答 4 个问题:
1. **"这是真问题还是臆想的?"** - 拒绝过度设计
2. **"有更简单的方法吗?"** - 永远寻找最简方案
3. **"会破坏什么吗?"** - 向后兼容是铁律
4. **"真的需要这个功能吗?"** - 确认功能必要性

**性能要求**:
- 最小化文件 I/O 操作次数
- 优先使用批量处理
- 合理使用多线程/异步处理大型 MOD
- 避免不必要的数据复制

**代码简洁性**:
- 能用 30 行解决,绝不写 300 行
- 复用现有代码
- 函数职责单一

#### 数据驱动的方案设计(强制)

**所有方案必须有充足的数据支撑**:

数据充足性判断:
- ✅ 是否完整理解现有代码实现逻辑?
- ✅ 是否掌握性能瓶颈数据?
- ✅ 是否了解用户实际使用场景?
- ✅ 是否分析业界最佳实践?
- ✅ 是否评估不同方案优劣?

**数据不足时的处理**:
```
⚠️ 我没有足够的信心设计最佳方案

需要以下数据:
1. [具体需要的数据1]
2. [具体需要的数据2]
...

请提供这些数据或告诉我如何获取。
```

**禁止**:
- ❌ 基于猜测或假设进行方案设计
- ❌ 数据不足时强行给出方案
- ❌ 使用"可能"、"也许"等不确定词汇描述关键决策

#### 方案审批流程(强制)

**在实施任何代码修改前,必须先获得用户审批**:

**工作流程**:
1. **分析阶段**: AI 使用只读工具 (Read/Grep/Glob) 深度分析代码
2. **方案设计**: 制定详细的实施方案 (见下方"方案文档要求")
3. **展示方案**: 向用户清晰展示方案,等待批准
4. **执行修改**: 获得批准后才开始实际修改代码

**方案文档要求**:
1. **提交方案设计文档**,包含:
   - 完整调用链路分析
   - 问题诊断和根因分析
   - **支撑数据和分析**(必须包含)
   - 方案设计 (架构图、时序图、代码片段)
   - KISS 原则 4 问题的回答
   - 性能影响评估
   - 风险分析和缓解措施
   - **文档保存**: 保存到 `docs/todo/YYYY-MM-DD-HH-MM-功能名称-方案.md`

2. **等待用户确认** - 批准后方可开始实施

3. **实施** - 严格按照批准方案执行

#### 分析检查清单

开始编码前必须完成:
- [ ] 已完整追踪调用链路
- [ ] 已理解所有涉及层的职责
- [ ] 已识别所有数据转换点
- [ ] 已回答 KISS 原则 4 个问题
- [ ] 已收集充足数据支撑方案
- [ ] 已制定详细实施方案
- [ ] 已获得用户审批确认

### 2. 功能版本迭代限制

**禁止版本迭代**: 对于存量功能,严格禁止版本迭代 (v1、v2、v3)

**核心原则**:
- **就地更新**: 所有改进必须直接修改现有代码
- **用户主导**: 只有用户明确要求才能创建新版本
- **单一实现**: 每个功能只能有一个实现版本
- **向后兼容**: 必须保持向后兼容
- **清理废弃**: 必须版本迭代时同时清理旧代码

### 3. 任务解析与影响分析

**任务前置分析原则**: 执行任何任务前,必须先进行全面分析

#### 文件影响评估
- **主要修改文件**: 直接需要编辑的核心文件
- **关联影响文件**: 可能受影响需同步更新的文件
- **测试相关文件**: 需要更新或新增的测试文件
- **配置文件**: 可能需要调整的配置

#### 依赖关系分析
- **文件依赖**: 识别导入/引用关系
- **功能依赖**: 识别模块间调用关系

#### 重复定义检查

添加任何新定义前,必须先检查:
```bash
# 检查函数/类定义
grep -r "function_name\|ClassName" --include="*.py"
```

**原则**: 避免重复实现,优先复用现有代码

### 4. 前置条件信任原则

**避免重复验证**: 信任调用链的前置条件

```python
# ❌ 过度防御: 重复验证已验证数据
def process_translation(data):
    if not data:
        return  # 前层已验证
    if not data.get('text'):
        return  # 前层已验证
    # ...

# ✅ 信任前置条件
def process_translation(data):
    # 前置条件: 调用方已验证 data 和 data['text'] 存在
    text = data['text']
    # 业务逻辑...
```

**分层职责**:
- **CLI/GUI 层**: 负责验证和防护
- **Service/Logic 层**: 信任前置条件,专注业务
- **Data/Storage 层**: 处理持久化,不做业务验证

---

## 交互规范(强制)

### 沟通原则
- **中文响应**: 所有响应使用中文
- **详细说明**: 提供清晰的操作步骤和说明
- **操作确认**: 重要操作前进行确认
- **透明度**: 如实汇报进度、问题和风险

### 主动提问机制(强制)
- **数据不足时提问**: 缺乏必要信息时,必须使用 `AskUserQuestion` 工具询问用户
- **明确性优先**: 遇到模糊需求时,通过提问明确用户意图
- **必须提问的场景**:
  - 技术方案有多种实现路径需权衡时
  - 需要删除或修改重要功能/数据时
  - 配置参数会显著影响系统行为时
  - 不确定用户具体需求时
  - 设计决策可能影响架构或性能时
  - 存在向后兼容性风险时
- **提问质量要求**:
  - 问题应具体、聚焦
  - 提供 2-4 个清晰选项
  - 每个选项附带详细说明
  - 说明各选项的影响和优缺点
- **等待确认**: 提问后必须等待用户回答

### 文件创建限制(强制)
- **禁止主动创建文档**: 不主动创建文档文件 (*.md) 或 README,除非用户明确要求
- **优先编辑**: 优先编辑现有文件而非创建新文件
- **必要性原则**: 只创建绝对必要的文件
- **用户确认**: 创建新文件前必须征得用户同意

---

## Python 项目特定规范

### 代码风格
- 遵循 PEP 8 规范
- 使用 black 进行代码格式化
- 使用 pylint 或 flake8 进行代码检查
- 类型注解: 使用 type hints (Python 3.9+)

### 目录结构
```
rimworld-mod-localization-assistant/
├── src/
│   ├── extractors/      # MOD 内容提取模块
│   ├── translators/     # 汉化管理模块
│   ├── storage/         # 数据存储模块
│   ├── ui/              # 界面模块 (CLI + GUI)
│   └── utils/           # 工具函数
├── tests/
│   ├── data/            # 测试数据
│   └── test_*.py        # 测试文件
├── docs/
│   └── todo/            # 方案文档
├── requirements.txt     # 依赖清单
└── CLAUDE.md            # 本文件
```

### 依赖管理
- 生产依赖: `requirements.txt`
- 开发依赖: `requirements-dev.txt`
- 使用国内镜像源:
  ```bash
  pip install -i https://pypi.tuna.tsinghua.edu.cn/simple
  ```

### 虚拟环境
- 使用 venv 或 virtualenv
- 开发前激活虚拟环境:
  ```bash
  python -m venv venv
  # Windows
  venv\Scripts\activate
  # Linux/Mac
  source venv/bin/activate
  ```

---

**最后更新**: 2025-11-11
